# 소프트웨어 세상을 여는 컴퓨터 과학 - 김종훈

### 개요

김종훈님의 서적 ‘소프트웨어 세상을 여는 컴퓨터 과학’ 을 읽고 정리했습니다.

---

### 1장: 컴퓨터의 개요

- 컴퓨터 시스템은 하드웨어와 소프트웨어로 구성됩니다.
    - 하드웨어는 컴퓨터를 구성하는 물리적인 기계 장치입니다.
        - 중앙처리장치, 기억장치, 입력장치, 출력장치로 구성됩니다.
    - 소프트웨어는 하드웨어에게 명령을 수행하라고 지시하며 이를 제어합니다.
        - 시스템 SW, 응용 SW로 나눠집니다. 둘은 수행하는 일이 다릅니다.
        - 시스템 SW는 하드웨어 자원을 효율적으로 관리하고 사용자 인터페이스를 지원합니다.
        - 응용 SW는 사용자가 필요하는 특정 업무를 수행하도록 도와줍니다.

---

### 2장: 데이터 표현과 디지털 논리

- 컴퓨터가 처음부터 2진수를 사용했던 것은 아니었습니다. 하지만 현재는 연산 처리 능력의 저하와 비안정성ㄷ의 문제로 인해 2진수를 사용합니다.
- 컴퓨터는 모든 정보를 2진수로 표현합니다. 그 중 문자는 **미리 약속된 코드 체계를 통해 표현**합니다. 대표적으로는 아스키 코드와 유니코드가 존재합니다.
    - 아스키 코드는 **A**merican **S**tandard Code for **I**nformation **I**nterchange의 약자입니다.
    - 위 이름에서 보이다시피 아스키 코드는 다양한 나라의 언어를 표현하기엔 어려움이 많았습니다. 이를 해결하기 위해 유니코드가 등장했습니다.
- 데이터의 효율적인 저장과 전송을 위해선 크기를 줄이는 것이 핵심입니다. 이를 우리는 압축이라고 말합니다. 텍스트 데이터에는 대표적인 압축 기술으로 **허프만 코딩**이 있습니다.
    - 사용 빈도를 기준으로 자주 사용되는 문자는 짧은 비트로, 적게 사용되는 비트는 상대적으로 긴 비트로 지정해 표현하는 기법입니다.
- 정수는 2의 보수 표기법을 통해 표현합니다. 컴퓨터는 특이하게 덧셈과 뺄셈 모두 더하기를 통해 수행합니다.
- 실수는 단일 정밀도와 이중 정밀도 형식을 통해 표현할 수 있습니다.
    - 실수 중 지수를 표현할 땐 음의 지수를 나타내기 위해 **바이어스 된 지수**로 표현합니다.
    - 실수를 표현하기 위한 절차 중 ‘가수 자리 조절'에서 가수 부분의 자리가 부족해 가수 일부분이 절단되는 오류를 **라운드 오프 오류(Round off error)**라고 합니다.
- 컴퓨터가 알아들을 수 있는 언어는 단 하나 ‘기계어'이며 0,1을 통해 표현됩니다. 0과 1에 대한 연산을 우린 **불 대수 연산**이라고 합니다.
    - OR, AND, NOT로 총 3개의 연산자가 존재합니다.
    - 위 연산자를 수행하는 연산을 논리 연산이라 부르며 이를 수행하는 회로를 **게이트**라고 부릅니다.
        - OR, AND, NOT과 같은 기본 게이트와 이를 확장한 XOR, NOR, NAND 게이트가 존재합니다.
        - 같은 결과를 도출하더라도 게이트 구성에 따라 연산 성능의 차이가 존재합니다.

---

# 소프트웨어 세상을 여는 컴퓨터 과학 - 김종훈

### 개요

김종훈님의 서적 ‘소프트웨어 세상을 여는 컴퓨터 과학’ 을 읽고 정리했습니다.

---

### 1장: 컴퓨터의 개요

- 컴퓨터 시스템은 하드웨어와 소프트웨어로 구성됩니다.
    - 하드웨어는 컴퓨터를 구성하는 물리적인 기계 장치입니다.
        - 중앙처리장치, 기억장치, 입력장치, 출력장치로 구성됩니다.
    - 소프트웨어는 하드웨어에게 명령을 수행하라고 지시하며 이를 제어합니다.
        - 시스템 SW, 응용 SW로 나눠집니다. 둘은 수행하는 일이 다릅니다.
        - 시스템 SW는 하드웨어 자원을 효율적으로 관리하고 사용자 인터페이스를 지원합니다.
        - 응용 SW는 사용자가 필요하는 특정 업무를 수행하도록 도와줍니다.

---

### 2장: 데이터 표현과 디지털 논리

- 컴퓨터가 처음부터 2진수를 사용했던 것은 아니었습니다. 하지만 현재는 연산 처리 능력의 저하와 비안정성ㄷ의 문제로 인해 2진수를 사용합니다.
- 컴퓨터는 모든 정보를 2진수로 표현합니다. 그 중 문자는 **미리 약속된 코드 체계를 통해 표현**합니다. 대표적으로는 아스키 코드와 유니코드가 존재합니다.
    - 아스키 코드는 **A**merican **S**tandard Code for **I**nformation **I**nterchange의 약자입니다.
    - 위 이름에서 보이다시피 아스키 코드는 다양한 나라의 언어를 표현하기엔 어려움이 많았습니다. 이를 해결하기 위해 유니코드가 등장했습니다.
- 데이터의 효율적인 저장과 전송을 위해선 크기를 줄이는 것이 핵심입니다. 이를 우리는 압축이라고 말합니다. 텍스트 데이터에는 대표적인 압축 기술으로 **허프만 코딩**이 있습니다.
    - 사용 빈도를 기준으로 자주 사용되는 문자는 짧은 비트로, 적게 사용되는 비트는 상대적으로 긴 비트로 지정해 표현하는 기법입니다.
- 정수는 2의 보수 표기법을 통해 표현합니다. 컴퓨터는 특이하게 덧셈과 뺄셈 모두 더하기를 통해 수행합니다.
- 실수는 단일 정밀도와 이중 정밀도 형식을 통해 표현할 수 있습니다.
    - 실수 중 지수를 표현할 땐 음의 지수를 나타내기 위해 **바이어스 된 지수**로 표현합니다.
    - 실수를 표현하기 위한 절차 중 ‘가수 자리 조절'에서 가수 부분의 자리가 부족해 가수 일부분이 절단되는 오류를 **라운드 오프 오류(Round off error)**라고 합니다.
- 컴퓨터가 알아들을 수 있는 언어는 단 하나 ‘기계어'이며 0,1을 통해 표현됩니다. 0과 1에 대한 연산을 우린 **불 대수 연산**이라고 합니다.
    - OR, AND, NOT로 총 3개의 연산자가 존재합니다.
    - 위 연산자를 수행하는 연산을 논리 연산이라 부르며 이를 수행하는 회로를 **게이트**라고 부릅니다.
        - OR, AND, NOT과 같은 기본 게이트와 이를 확장한 XOR, NOR, NAND 게이트가 존재합니다.
        - 같은 결과를 도출하더라도 게이트 구성에 따라 연산 성능의 차이가 존재합니다.

---

### 3장: 컴퓨터 구조

- 컴퓨터를 구성하는 요소 중 하드웨어는 중앙처리장치(CPU), 주기억장치(RAM), 보조기억장치(HDD,SDD), 입출력장치(마우스, 키보드, 모니터, 스피커) 등이 있습니다.
    - 중앙처리장치는 크게 제어, 연산, 레지스터 집합 세 부분으로 구성됩니다. 주기억장치를 비롯한 다른 장치들과 버스로 연결되어 있으며, 프로그램 명령어를 해독하여 실행하는 일을 합니다.
        - **인출(fetch) → 해독(decode) → 실행(execute)** 순서로 명령어를 수행합니다.
    - 주기억장치는 프로그램과 실행에 필요한 데이터를 일시적으로 저장합니다. 중앙처리장치와는 버스를 통해 상호작용합니다.
        - 버스는 목적에 따라 제어 버스(쓰기 혹은 읽기를 결정), 주소 버스, 데이터 버스로 나눠집니다.
- 컴퓨터는 사용자가 컴퓨터를 사용할 수 있는 환경을 준비하기 위한 준비 단계가 필요합니다. 이를 부팅이라고 합니다.
    - 부팅은 바이오스 실행 → 부팅 프로그램 실행 → 운영체제 실행 순으로 진행됩니다.
        - 바이오스 BIOS 프로그램은 그래픽 카드 초기화, 주기억 장치, 디스크 드라이브, 키보드 등의 하드웨어 장치의 상태를 검사합니다.
        - 문제가 없으면 보조기억장치의 부트 섹터에 저장된 부팅 프로그램을 주기억장치로 이동시킵니다.
        - 부팅 프로그램이 실행되며 시스템 제어권을 넘겨받습니다. 보조기억장치에서 운영체제를 찾아 주기억장치에 올려 운영체제가 실행됩니다.
- 프로그램을 구성하는 명령어는 연산 코드와 피연산자로 구성됩니다.
    - 명령어는 데이터 전송, 연산, 분기 명령어로 나눠집니다.
        - 데이터 전송 명령어는 주기억장치와 레지스터 사이에서 데이터를 전송하라는 명령입니다. MOV, PUSH, POP 등이 있습니다.
        - 연산 명령어는 산술 연산(ADD, SUB, MUL, DIV), 논리 연산(AND, OR, NOT, XOR), 시프트(SHR, SHL, CIR, CIL) 명령어로 구분됩니다.
        - 분기 명령어는 일반적인 순차적인 실행 순서와 다르게 특정 위치로 명령어의 실행 순서를 이동시키는 명령입니다. 특정 주소로 분기하는 JUMP, 분기 후 돌아올 때 사용되는 CALL이 있습니다.

---

### 4장: 운영체제의 개요

- 운영체제는 사용자가 컴퓨터를 편리하게 사용할 수 있도록 **‘사용자 인터페이스를 제공’**하며 하드웨어의 각 장치를 관리하는 **’컴퓨터 시스템 자원 관리'** 두 기능을 수행합니다.
    - 컴퓨터 시스템 자원 중 중앙처리장치는 주기억장치에 준비된 프로그램, 프로세스를 실행합니다.
- Process is Program in Execution
    - 프로세스는 실행중인 프로그램입니다. ‘실행중’이란 것은 보조기억장치에 보관되어있던 프로그램이 주기억장치로 로드된 상태를 말합니다.
    - 프로세스는 운영체제의 실행 제어를 돕기 위한 여러 정보를 갖습니다. 이런 정보들을 담은 주머니를 **Process Control Block, PCB**라고 합니다. PCB는 아래와 같은 요소들로 이뤄져 있습니다.
        - **PID**: 프로세스만의 고유한 번호입니다. 고유값을 갖고 있어야 서로의 메모리 영역을 침범하지 않을 수 있고, 서로 통신할 때도 식별이 가능합니다.
        - **State:** 프로세스의 현재 상태를 말합니다.
            - 프로세스는 항상 CPU를 붙잡고 실행(점유)되는게 아닙니다. 가끔 CPU가 프린터, 마우스, 키보드같은 입출력 장치를 이용하게 되면 잠시 놔주어야 합니다.
            - 이 때 프로세스가 CPU를 점유하고있지 않다는 **대기 상태**를 표시하기 위해 필요합니다.
        - **Pointer**: 프로세스가 위치하고 있는 메모리 주소 정보입니다.
            - 각각의 프로세스는 고유의 영역을 갖습니다. 이 영역이 어디인지 알기 위해 필요합니다.
            
            <p align="center"><img src="img/pcb.png"></p>
            
        - **Priority**: CPU를 선점할 수 있는 우선권을 말합니다.
            - 우린 state를 사용해서 CPU를 누가 점유하는지 확인할 수 있습니다. 이 때 I/O 장치가 더이상 CPU를 필요로 하지 않는다면 대기 상태였던 프로세스가 다시 CPU를 점유할 수 있도록 순서를 정해줘야 합니다. 이 때 필요한게 바로 우선권입니다.
        - **Program counter**: 하나의 프로세스 내에서 다음 차례에 수행될 명령어의 주소 값입니다.
        - **I/O information**: 프로세스가 할당받은 I/O 자원들에 대한 정보입니다.
        - **Accounting information**: CPU를 사용한 시간 정보입니다.
    - 프로세스는 실행되는 동안 총 5가지의 상태를 갖습니다.
        
        <p align="center"><img src="img/process-status.png"></p>
        
        - 생성, 준비, 대기, 실행, 종료
        - 운영체제가 ‘실행 상태의 프로세스 → 준비 상태’, ‘준비 상태의 프로세스 → 실행 상태’로 변경할 땐CPU의 레지스터에 저장되어 있는 프로세스의 정보를 서로 바꾸게 되는데 이를 **컨텍스트 스위칭**이라고 합니다. 이 때 CPU는 아무런 일도 하지 못합니다. 따라서 잦은 컨텍스트 스위칭은 CPU의 이용률 저하, 즉 성능 저하를 일으킵니다.
    - 여러 개의 프로세스 실행을 통해 얻고자 하는 것은 CPU 이용률의 최대화입니다. 즉 프로세스의 실행 순서를 효율적으로 배치할수록 이용률이 올라갑니다. 이를 위한 기법을 **프로세스 스케줄링**이라고 합니다.
        - FCFS(First-come First-served) 스케줄링
        - 라운드 로빈(Round Robin) 스케줄링: 프로세스들이 돌아가며 정해진 시간 할당량동안 CPU를 점유합니다. 시간 할당량을 적절하게 설정하는 것이 성능에 매우 큰 영향을 미치며 일반적으로 100~100ms을 가집니다.
        - 우선 순위 스케줄링
- 현재 컴퓨터는 보조기억장치에 운영체제와 프로세스 하나만 로드하는 단일 연속 주기억장치보단 여러 프로세스를 영역을 나눠 저장하는 형태를 띕니다.
    - 최초, 최적, 적합 등의 메모리 할당 방식이 존재하지만 최근엔 대부분 **가상 메모리 방식**을 지원합니다.
    - 주기억장치는 생각보다 용량이 작습니다. 따라서 자신보다 큰 프로그램은 정상적으로 실행되지 않을 수 있습니다. 또한 여러 개의 프로그램을 한번에 실행해야될 때도 마찬가지입니다.
    - 이럴 때 당장 실행에 **필요한 부분만 주기억장치에 저장**하고 **나머지는 보조기억장치에 두고 동작**하도록 하는 방식이 바로 가상 메모리입니다.
        - 주기억장치에 올릴 부분을 산정하기 위해 프로그램을 일정한 크기로 나눕니다. 이 때 나누는 단위를 **페이지**라고 하며 페이지 단위로 주기억장치에 올리며 동작하는 것을 **페이징**이라고 합니다.
        - 주기억장치에 페이지가 올라갔을 때 해당되는 부분을 페이지 프레임이라고 합니다.
        - 페이지를 교체하기 위한 알고리즘은 FIFO(First In First Out), LRU(Least Recently Used), LFU(Least Frequently Used)가 있습니다.
